package main

import (
	"log"
	"time"

	mpv "github.com/gregadams4/mpvjson"
)

func main() {
	c, err := mpv.Open("/tmp/mpvsocket")
	if err != nil {
		log.Println(err)
	}
	defer c.Close()

	res, err := c.Run("loadfile", "some-file-to-play-in-mpv.mkv")
	if err != nil {
		log.Println(err)
	}
	log.Println(res)

	log.Println("pausing")
	res, err = c.Set("pause", true)
	if err != nil {
		log.Println(err)
	}
	log.Println(res)

	//Currently a known bug in which this can cause a data race and crash due to concurrent read write on a map. Working on getting it fixed but couldn't get the logic right yet.
	// for i := 1; i < 100; i++ {
	// 	go func() {
	// 		res, err = c.Get("pause")
	// 		if err != nil {
	// 			log.Println(err)
	// 		}
	// 		log.Printf("%d - %v", res.RequestID, res)
	// 	}()
	// }

	time.Sleep(1 * time.Second)
	log.Println("unpausing")
	res, err = c.Set("pause", false)
	if err != nil {
		log.Println(err)
	}
	log.Println(res)

	timeRemainingC := make(chan mpv.Response)
	continueWatchingTimeC := make(chan bool)
	log.Println("opening time remaining.")
	//to observe a property you must pass in a channel which will receive events generated by mpv for the property you are watching, and a second channel will stop observing the property after you pass something to.
	err = c.Observe(timeRemainingC, continueWatchingTimeC, "time-remaining")
	if err != nil {
		log.Println(err)
		return
	}

	for {
		res := <-timeRemainingC
		log.Println(res)
		if res.Data.(float64) < 400 {
			log.Println("under 400 seconds remaining.")
			continueWatchingTimeC <- false
			close(continueWatchingTimeC)
			break
		}
	}
	// log.Println(res)
	time.Sleep(1 * time.Second)
	err = c.Close()
	if err != nil {
		log.Println(err)
	}
}
